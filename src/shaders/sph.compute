#include "bgfx_compute.sh"

BUFFER_RW(u_particle, vec2, 0);
BUFFER_RW(u_pixels, vec4, 1);
BUFFER_RW(u_densities, vec4, 2);
BUFFER_RW(u_velocities, vec2, 3);

uniform vec4 u_numPoints;
uniform vec4 u_radius;
uniform vec4 u_resolution;

float SmoothingKernelDerivative(float radius, float dst){
  if(dst >= radius){
    return 0;
  }
  float f = radius * radius - dst * dst;
  float scale = -24 / (3.14159265359 * pow(radius, 8.0));
  return scale * dst * f * f;
}

float Distance2Vectors(vec2 A, vec2 B) {
    return length(A - B);
}

float DensityToPressure(float density){
  float densityError = density - 3;
  float pressure = densityError * 1;
  return pressure;
}

vec2 CalculatePressureForce(int sampleIndex){
  vec2 pressureForce = vec2(0,0);
  const float mass = 1.0;

  for(int particleIndex = 0; particleIndex < u_numPoints.x; particleIndex++){
    if(sampleIndex == particleIndex) continue;

    vec2 normalizedSample = (u_particle[sampleIndex] + 1) / 2;
    vec2 normalizedPoint = (u_particle[particleIndex] + 1) / 2;
    float normalizedRadius = u_radius.x / u_resolution.x;

    vec2 offset = normalizedPoint - normalizedSample;
    float dst = Distance2Vectors(normalizedPoint, normalizedSample);
    vec2 dir = offset / dst;

    float slope = SmoothingKernelDerivative(normalizedRadius, dst);
    float density = u_densities[particleIndex].x;
    pressureForce += DensityToPressure(density) * dir * slope * mass / density;
  }
  return pressureForce;
}

NUM_THREADS(256, 1, 1)
void main() {
  uint idx = gl_GlobalInvocationID.x;

  vec2 pressureForce = CalculatePressureForce(idx);
  vec2 pressureAcceleration = pressureForce / u_densities[idx].x;

  u_velocities[idx] = pressureAcceleration * 0.008;
}
